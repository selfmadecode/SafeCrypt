using System;
using System.Security.Cryptography;

namespace SafeCrypt.Helpers
{
    public class KeyGenerators
    {

        /// <summary>
        /// Generates an array of random bytes using a cryptographically secure random number generator.
        /// </summary>
        /// <param name="length">The length of the byte array to generate.</param>
        /// <returns>An array of random bytes or the IV key</returns>
        /// <remarks>
        /// The method uses a cryptographically secure random number generator (RNGCryptoServiceProvider) to generate
        /// a byte array with the specified length, providing a high level of randomness suitable for cryptographic use.
        /// </remarks>
        /// <param name="length">The desired length of the generated byte array.</param>
        /// <returns>An array of random bytes with the specified length.</returns>
        /// <exception cref="ArgumentException">
        /// Thrown if the specified length is less than or equal to zero.
        /// </exception>
        public static byte[] GenerateRandomIVKeyAsBytes(int length)
        {
            byte[] randomBytes = new byte[length];
            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())
            {
                rng.GetBytes(randomBytes);
            }
            return randomBytes;
        }

        /// <summary>
        /// Generates a random initialization vector (IV) key as a hexadecimal string.
        /// </summary>
        /// <returns>
        /// A hexadecimal string representation of the randomly generated IV key.
        /// </returns>
        /// <remarks>
        /// This method internally uses the <see cref="GenerateRandomIVKeyAsBytes"/> method
        /// to obtain a random byte array and then converts it to a hexadecimal string using
        /// <see cref="BitConverter.ToString"/>. Any hyphens in the resulting string are removed
        /// using <see cref="string.Replace"/>.
        /// </remarks>
        public static string GenerateRandomIVKeyAsString()
        {
            byte[] randomBytes = GenerateRandomIVKeyAsBytes(16);            
            return BitConverter.ToString(randomBytes).Replace("-", "");
        }

        /// <summary>
        /// Generates a valid AES secret key with the specified key size.
        /// </summary>
        /// <param name="keySize">The desired key size (128, 192, or 256 bits).</param>
        /// <returns>A valid AES secret key as a byte array.</returns>
        public static string GenerateAesSecretKey(int keySize)
        {
            if (keySize != 128 && keySize != 192 && keySize != 256)
            {
                throw new ArgumentException("Invalid key size. Supported sizes are 128, 192, or 256 bits.", nameof(keySize));
            }

            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.KeySize = keySize;
                aesAlg.GenerateKey();
                return Convert.ToBase64String(aesAlg.Key);
            }
        }

        /// <summary>
        /// Generates a pair of RSA public and private keys with the specified key size.
        /// </summary>
        /// <param name="keySize">The size of the key pair (e.g., 1024, 2048 bits).</param>
        /// <returns>
        /// A <see cref="Tuple{T1, T2}"/> containing the generated RSA public and private keys.
        /// Item1 represents the public key, and Item2 represents the private key.
        /// </returns>
        /// <remarks>
        /// The generated keys are in XML format. The public key does not include the private key,
        /// while the private key includes both public and private components.
        /// </remarks>
        /// <param name="keySize">The size of the key pair (e.g., 1024, 2048 bits).</param>
        /// <returns>A tuple containing the generated RSA public and private keys.</returns>
        /// <exception cref="CryptographicException">
        /// Thrown if an error occurs during key generation.
        /// </exception>
        public static Tuple<string, string> GenerateRsaKeys(int keySize)
        {
            using (var rsa = new RSACryptoServiceProvider(keySize))
            {
                string publicKey = rsa.ToXmlString(false); // Don't include private key
                string privateKey = rsa.ToXmlString(true); // Include private key

                return new Tuple<string, string>(publicKey, privateKey);
            }
        }
    }
}
